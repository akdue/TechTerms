# **Digital Signature**

## الترجمة الحرفية  
**Digital Signature** — **توقيع رقمي** يثبت **الهوية** و**سلامة المحتوى** باستخدام **تشفير غير متماثل**.

## الوصف العربي المختصر  
آلية تُنتج **بصمة موقَّعة** لرسالة/ملف بواسطة **المفتاح الخاص** للمرسل،  
ويتحقق المتلقي منها باستخدام **المفتاح العام**. توفر **أصالة (Authenticity)** و**سلامة (Integrity)** و**عدم إنكار** نسبيًا.

## الشرح المبسّط  
- نحسب **هاش** للرسالة ثم نُوقّع الهاش بالمفتاح الخاص.  
- المراجع يستخدم **المفتاح العام** للتحقق؛ إذا تغيرت بايت واحد تفشل.  
- خوارزميات شائعة: **RSA-PSS**، **ECDSA (P-256/P-384)**، **Ed25519**.  
- يمكن أن يكون التوقيع **منفصلًا** (Detached) أو **مرفقًا** بالرسالة.

## تشبيه  
ختم شمعي خاص بك على رسالة.  
أي شخص يعرف **شكل ختمك** (المفتاح العام) يتأكد أن الرسالة منك ولم تُعبث.

## مثال كود C# بسيط (RSA-PSS + SHA-256)

```csharp
using System;
using System.Security.Cryptography;
using System.Text;

class SignDemo
{
    static void Main()
    {
        // 1) توليد زوج مفاتيح (للتجربة فقط؛ احفظ المفاتيح بشكل آمن في الإنتاج)
        using var rsa = RSA.Create(2048);

        // 2) توقيع رسالة
        string message = "Important payload";
        byte[] data = Encoding.UTF8.GetBytes(message);
        byte[] sig = rsa.SignData(data, HashAlgorithmName.SHA256, RSASignaturePadding.Pss);

        Console.WriteLine(Convert.ToBase64String(sig)); // توقيع Base64

        // 3) التحقق من التوقيع بالمفتاح العام
        bool ok = rsa.VerifyData(data, sig, HashAlgorithmName.SHA256, RSASignaturePadding.Pss);
        Console.WriteLine(ok); // True

        // ملاحظة: خزّن المفتاح الخاص بأمان (HSM/KeyVault)، ووزّع المفتاح العام/شهادة X.509 للمتحققين.
    }
}
```

> بدائل مختصرة:  
> - **ECDsa**: `using var ecdsa = ECDsa.Create(ECCurve.NamedCurves.nistP256);` ثم `ecdsa.SignData/VerifyData`.  
> - **Ed25519** (في مكتبات خارجية/أنظمة أخرى): سريع وبسيط للمفاتيح.

## خطوات عملية لاستخدام التوقيع الرقمي
- اختر خوارزمية مناسبة: **Ed25519/ECDSA** للسرعة والحجم، أو **RSA-PSS** للتوافق الواسع.  
- ثبّت **التغليف/الصيغة**: **JWS/JWT**, **CMS (PKCS#7)**, **XMLDSig**, أو بصيغة تطبيقك (Detached/Attached).  
- استخدم **هاش حديث** (SHA-256 أو أعلى) و**وسم سياقي** إن لزم (Domain Separation).  
- خزّن الخاص في **HSM/Key Vault**، ودوّر المفاتيح وخطّط للإبطال (Revocation).  
- للملفات/الوثائق طويلة الأمد: أضف **ختم زمني** (Timestamp/TSA) وحِزم ثقة.  
- مع JSON/XML: طبّق **تقنين (Canonicalization)** لتجنّب اختلافات التنسيق عند التحقق.  
- اربط المفتاح بهوية عبر **شهادة X.509** إن أردت هوية قانونية/مؤسسية.

## أخطاء شائعة
- استخدام **RSA PKCS#1 v1.5** بدل **RSA-PSS** الحديثة.  
- توقيع **البيانات الخام** دون تحديد صيغة/قواعد واضحة → صعوبة التحقق عبر الأنظمة.  
- نسيان **التقنين** لـ JSON/XML → يفشل التحقق رغم عدم تغيّر المعنى.  
- خلط **التوقيع** مع **التشفير** (الترتيب مهم): غالبًا **وقّع ثم شفّر** أو استخدم حاوية تدعم الاثنين.  
- إعادة استخدام نفس **المفتاح** للتوقيع والتشفير بلا سياسة فصل أدوار.  
- تجاهل **الإبطال**/الانتهاء للشهادات وعدم مراقبة صلاحيتها.

## جدول مقارنة مختصر

| المفهوم                     | الغرض الرئيسي                       | ملاحظات مهمة                                            |
| --------------------------- | ----------------------------------- | ------------------------------------------------------- |
| [Encryption](encryption.md) | إخفاء المحتوى ليسترجعه صاحب المفتاح | يوفر **سرّية**؛ ليس إثبات هوية المرسل                    |
| **Digital Signature**       | **أصالة المرسل + سلامة المحتوى**    | **تتحقق بالمفتاح العام؛ يوصى بـ RSA-PSS/ECDSA/Ed25519** |
| [Hashing](hashing.md)       | بصمة للتحقق/الفهرسة                 | غير قابل للعكس؛ بدون هوية؛ استخدم مع توقيع/HMAC للحماية |

## ملخص الفكرة  
**التوقيع الرقمي** يثبت أن الرسالة **من صاحب المفتاح الخاص** ولم تتغيّر.  
اختر خوارزمية حديثة، ثبّت صيغة التبادل، واحفظ مفاتيحك في حاويات آمنة مع سياسات دوران وإبطال واضحة.
